const puppeteer = require('puppeteer');
const fs = require('fs');

/**
 * Generates a PDF report matching the "Foundation for Ed-Equity" Audit Report format.
 * Recreates the exact layout using clean HTML/CSS Tables instead of fragile absolute positioning.
 */
const generateReportFromHtml = async (data, templatePath, outputPath) => {
    try {
        //console.log(`Generating Structured Audit Report...`);

        const cob = data.cob_report || {};
        const headerData = cob.header || {};
        const scores = cob.scores || {};
        const params = cob.parameters || [];

        // 1. Build The Header HTML (Foundation for Ed-Equity Style)
        const headerHtml = `
            <div style="font-family: Arial, sans-serif; position: relative; margin-bottom: 20px;">
                <div style="text-align: right; font-weight: bold; color: #555; font-size: 14px; margin-bottom: 5px;">
                    FOUNDATION FOR<br>
                    <span style="font-size: 18px; color: #444;">ED-EQUITY</span>
                </div>
                
                <div style="border-bottom: 2px solid #ccc; margin-bottom: 15px;"></div>

                <div style="display: flex; justify-content: space-between; align-items: flex-end; margin-bottom: 15px;">
                    <div style="font-size: 16px; font-weight: bold; color: #0000CC;">CLASSROOM OBSERVATION â€“ AUDIT REPORT</div>
                    <div style="text-align: right; font-size: 10px; color: #333;">
                        Filename: <b>${headerData.school || 'School'}_COB${headerData.round || '1'}_${headerData.facilitator || 'Teacher'}_${headerData.date || 'Date'}</b>
                    </div>
                </div>

                <table class="meta-table">
                    <tr>
                        <td class="label">Teacher:</td>
                        <td class="value">${headerData.facilitator || 'N/A'}</td>
                        <td class="label">School:</td>
                        <td class="value">${headerData.school || 'N/A'}</td>
                    </tr>
                    <tr>
                        <td class="label">Grade:</td>
                        <td class="value">${headerData.grade || 'N/A'}</td>
                        <td class="label">Section:</td>
                        <td class="value">${headerData.section || 'N/A'}</td>
                        <td class="label">Subject:</td>
                        <td class="value">${headerData.subject || 'N/A'}</td>
                    </tr>
                    <tr>
                        <td class="label">Observation Date:</td>
                        <td class="value">${headerData.date || 'N/A'}</td>
                        <td class="label">BLM / Chapter:</td>
                        <td class="value">${headerData.topic_blm || 'N/A'}</td>
                        <td class="label">Duration:</td>
                        <td class="value">${headerData.duration && headerData.duration !== 'N/A' ? headerData.duration : '45m'}</td>
                    </tr>
                    <tr>
                        <td class="label">Type:</td>
                        <td class="value">Informed</td>
                        <td colspan="4" style="font-size: 9px; color: #0000CC; vertical-align: bottom;">
                            Type of session = Assignment Solving, Concept Discussion, Activity, etc
                        </td>
                    </tr>
                    <tr>
                        <td class="label">Type of Session:</td>
                        <td class="value">${headerData.session_type || 'Classroom'}</td>
                        <td class="label">Interaction No.:</td>
                        <td class="value">01</td>
                        <td class="label">Session No.:</td>
                        <td class="value">01</td>
                    </tr>
                </table>

                <div style="margin-top: 15px; display: flex; align-items: flex-start;">
                    <div style="font-weight: bold; font-size: 12px; margin-right: 10px; padding-top: 5px;">Overall Score:</div>
                    <div style="font-weight: bold; font-size: 14px; border: 1px solid #000; padding: 4px 8px;">${scores.overall_percentage || '0%'}</div>
                    <div style="margin-left: 15px; font-size: 10px; font-style: italic; color: #0000CC; padding-top: 6px;">Overall Score is Autogenerated</div>
                </div>
            </div>
        `;

        // 2. Build Segment Scores Table
        // Use the dynamic helper instead of hardcoded rows
        const segmentHtml = generateDynamicSegmentTable(params);

        // 3. Build Detailed Parameters Table
        let tableBody = '';

        // Dynamic Category Extraction
        // We want to preserve the order if possible, or just group them.
        // Let's deduce categories and weights from the parameters themselves if available, 
        // or just group by 'category' string.

        const grouped = {};
        const categoryOrder = []; // To keep track of order of appearance

        params.forEach(p => {
            const cat = p.category || 'General'; // Default if missing
            if (!grouped[cat]) {
                grouped[cat] = [];
                categoryOrder.push(cat);
            }
            grouped[cat].push(p);
        });

        categoryOrder.forEach(catName => {
            const catParams = grouped[catName];
            // Calculate pseudo-weight or use provided
            const totalMaxScore = catParams.reduce((sum, p) => sum + (p.out_of || 0), 0);

            // Render Category Header
            tableBody += `
                <tr class="category-header">
                    <td colspan="5" style="text-align: right; padding-right: 15px; background-color: #e6e6e6; font-weight: bold; color: #0000FF; border: 1px solid #000;">
                        ${catName}
                    </td>
                </tr>
            `;

            // Render Parameters for this Category
            catParams.forEach(p => {
                const score = p.score !== undefined ? p.score : 0;
                const max = p.out_of || 2;
                const weight = (p.weight && p.weight !== 'N/A') ? p.weight : '1';

                tableBody += `
                    <tr>
                        <td style="border: 1px solid #000; padding: 5px; width: 30%;">
                            <b>${p.name}</b><br>
                            <span style="font-size: 9px; color: #555;">(Score based on observation)</span>
                        </td>
                        <td style="border: 1px solid #000; padding: 5px; text-align: center; vertical-align: middle; font-weight: bold;">${score}</td>
                        <td style="border: 1px solid #000; padding: 5px; text-align: center; vertical-align: middle;">${max}</td>
                        <td style="border: 1px solid #000; padding: 5px; text-align: center; vertical-align: middle;">${weight}</td>
                        <td style="border: 1px solid #000; padding: 5px; font-size: 10px;">${p.comment || 'No comments provided.'}</td>
                    </tr>
                `;
            });
        });

        // 4. Assemble Final HTML
        const finalHtml = `
            <!DOCTYPE html>
            <html>
                <head>
                    <meta charset="UTF-8">
                    <style>
                        body { font-family: Arial, sans-serif; font-size: 11px; padding: 20px; }
                        .meta-table { width: 100%; border-collapse: collapse; margin-bottom: 20px; font-size: 11px; }
                        .meta-table td { padding: 4px; }
                        .meta-table .label { font-weight: bold; width: 120px; }
                        .meta-table .value { font-weight: bold; color: #000; border-bottom: 1px dotted #ccc; }
                        
                        .main-table { width: 100%; border-collapse: collapse; font-size: 11px; margin-top: 10px; }
                        .main-table th { background-color: #f2f2f2; border: 1px solid #000; padding: 5px; text-align: center; font-weight: bold; }
                        .main-table td { border: 1px solid #000; padding: 5px; vertical-align: top; }
                    </style>
                </head>
                <body>
                    ${headerHtml}
                    ${segmentHtml}
                    <br>
                    <table class="main-table">
                        <thead>
                            <tr>
                                <th>Parameter</th>
                                <th width="50">Score</th>
                                <th width="50">Out of</th>
                                <th width="60">Weightage</th>
                                <th>Comments</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${tableBody}
                        </tbody>
                    </table>
                    <div style="margin-top: 20px; font-size: 10px; text-align: center; color: #888;">
                        Generated by AI School Audit System | Foundation for Ed-Equity
                    </div>
                </body>
            </html>
        `;

        // 5. Generate PDF
        const browser = await puppeteer.launch({
            headless: 'new',
            args: ['--no-sandbox', '--disable-setuid-sandbox']
        });
        const page = await browser.newPage();
        await page.setContent(finalHtml, { waitUntil: 'networkidle0' });
        await page.pdf({
            path: outputPath,
            format: 'A4',
            printBackground: true,
            margin: { top: '30px', bottom: '30px', left: '20px', right: '20px' }
        });
        await browser.close();

        return outputPath;

    } catch (error) {
        console.error("HTML Report Generation Error:", error);
        throw error;
    }
};

function generateSegmentRow(params, key, label) {
    // If key is null, it means we are just using the label as the exact category name
    const searchKey = key || label;

    // Exact match or Include match depending on robust we want to be
    // Using simple filter for now. If we want fully dynamic segments table:
    // We should probably rewrite this function to iterate over the unique categories found.
    return '';
}

// Helper to generate the full segment table dynamically
function generateDynamicSegmentTable(params) {
    const grouped = {};
    params.forEach(p => {
        const cat = p.category || 'General';
        if (!grouped[cat]) grouped[cat] = [];
        grouped[cat].push(p);
    });

    const rows = Object.keys(grouped).map(catName => {
        const catParams = grouped[catName];
        const score = catParams.reduce((acc, p) => acc + (p.score || 0), 0);
        const total = catParams.reduce((acc, p) => acc + (p.out_of || 0), 0);
        const percentage = total ? ((score / total) * 100).toFixed(0) + '%' : 'N/A';

        return `
            <tr>
                <td style="border: 1px solid #000; padding: 4px; text-align: center;">${percentage}</td>
                <td style="border: 1px solid #000; padding: 4px;">${catName}</td>
            </tr>
        `;
    }).join('');

    return `
        <table class="segment-table" style="width: 60%; margin: 10px auto; border-collapse: collapse; font-family: Arial, sans-serif; font-size: 11px;">
            <tr style="background-color: #f2f2f2;">
                <td colspan="2" style="text-align: center; font-weight: bold; color: #0000CC; border: 1px solid #000; padding: 4px;">Segment Scores</td>
            </tr>
            <tr style="background-color: #ddd; font-weight: bold;">
                <td style="border: 1px solid #000; padding: 4px; width: 30%; text-align: center;">Score</td>
                <td style="border: 1px solid #000; padding: 4px;">Segments</td>
            </tr>
            ${rows}
        </table>
    `;
}

module.exports = { generateReportFromHtml };
